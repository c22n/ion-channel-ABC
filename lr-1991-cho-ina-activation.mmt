[[model]]
name: ChoNaLR1
desc: """
    Cho cell with Sodium channel based on LR1.
    
    This example shows how to manually perform an activation experiment. Note
    that automated methods to perform similar tasks are also provided in
    myokit.lib.common.
    """
author: Michael Clerx
# Initial values
ina.m = 0
ina.h = 1
ina.j = 1

# Environment variables
[engine]
time = 0 bind time
pace = 0 bind pace

[membrane]
V = -80

[ina]
use membrane.V as V
ENa = 41
Gbar = 16
INa = Gbar * m^3 * h * j * (V - ENa)
a = 1 - 1 / (1 + exp(-(V + 40) / 0.24))
dot(m) =  alpha * (1 - m) - beta * m
    alpha = 0.32 * (V + 47.13) / (1 - exp(-0.1 * (V + 47.13)))
    beta  = 0.08 * exp(-V / 11)
dot(h) =  alpha * (1 - h) - beta * h
    alpha = a * 0.135 * exp((80 + V) / -6.8)
    beta  = a * (3.56 * exp(0.079 * V) + 3.1e5 * exp(0.35 * V)) \
          + (1 - a) / (0.13 * (1 + exp((V + 10.66) / -11.1)))
dot(j) =  alpha * (1 - j) - beta * j
    alpha = a * ( -127140 * exp(0.2444 * V) - 3.474e-5 * exp(-0.04391 * V)) \
              * (V + 37.78) / (1 + exp(0.311 * (V + 79.23)))
    beta  = a * (0.1212 * exp(-0.01052 * V) / (1 + exp(-0.1378 * (V + 40.14)))) \
          + (1 - a) * (0.3 * exp(-2.535e-7 * V) / (1 + exp(-0.1 * (V + 32))))



[[script]]
import matplotlib.pyplot as pl
import numpy as np
import myokit

#
# This example shows how to simulate an activation experiment "by hand" (i.e.
# without using the class myokit.lib.common.Activation).
#
# It also shows how a step protocol experiment is unable to extract the
# steady state activation perfectly, as inactivation kicks in at higher
# potentials.
#

# Holding potentials to test
holding_potentials = np.arange(-90, 60, 10)

# Create simulation
m = get_model()
s = myokit.Simulation(m)

# Create figure for results
pl.figure()

# Top-left: the holding potentials
pl.subplot(2,2,1)
pl.title('Holding potential')
pl.ylim([-100, 60])

# Top-right: simulated INa traces (overlaid)
pl.subplot(2,2,2)
pl.title('Simulated INa')
pl.xlim([0, 3])
pl.ylim([-400, 100])

# Bottom-left: IV profile
pl.subplot(2,2,3)
pl.title('IV curve')
pl.xlim([-100, 60])
pl.ylim([-400, 100])

# Bottom-right: Activation / Normalized conductance
pl.subplot(2,2,4)
pl.title('Activation')
pl.xlim([-100, 70])
pl.ylim([-0.1, 1.1])

# Create list to store peak currents in
peaks = []

# Run simulations
for vhold in holding_potentials:

    # Pre-pace at low potential
    s.set_constant('membrane.V', -140)
    s.pre(5000)
    
    # Perform step
    s.set_constant('membrane.V', vhold)
    d = s.run(25)
    
    # Change the logged times so all simulated INa traces overlap
    d = d.npview()
    d['engine.time'] -= d['engine.time'][0]
    
    # Plot the voltage step
    pl.subplot(2,2,1)
    pl.plot(d['engine.time'], vhold * np.ones(d['engine.time'].shape))

    # Plot INa
    pl.subplot(2,2,2)
    pl.plot(d['engine.time'], d['ina.INa'])
    
    # Find peak current
    current = d['ina.INa']
    index = np.argmax(np.abs(current))
    peak = current[index]
    peaks.append(peak)
    
    # Plot peak
    pl.subplot(2,2,3)
    pl.plot(vhold, peak, marker='o')

# Now, calculate the activation / normalized conductance
# - Get the reversal potential
reversal_potential = m.get('ina.ENa').value()
# - Create a numpy array with the peak currents
peaks = np.array(peaks)
# - Divide the peak currents by (V - E)
act = peaks / (holding_potentials - reversal_potential)
# - Normalize by dividing by the biggest value
act = act / np.max(act)

# Display the activation measured in the protocol
pl.subplot(2,2,4)
pl.plot(holding_potentials, act, label='simulated')

# Now, let's compare this with the model values
# - Get python functions to evaluate m.alpha and m.beta
#   To do this, make V a state variable, and then use pyfunc() to get the
#   equations for alpha and beta as functions of V
v = m.get('membrane.V')
v.promote()
a = m.get('ina.m.alpha').pyfunc('V')
b = m.get('ina.m.beta').pyfunc('V')
# - Evaluate these functions at the holding potentials
A = a(holding_potentials)
B = b(holding_potentials)
# - Calculate activation:
m = A / (A + B)

# Display the model activation
pl.plot(holding_potentials, m, label='m_inf')
pl.plot(holding_potentials, m**3, label='m_inf^3')
pl.legend(loc='lower right')

# Display the results
pl.show()

